''' HEIGHT = maxPyrHt(IMSIZE, FILTSIZE)

     Compute maximum pyramid height for given image and filter sizes.
     Specifically: the number of corrDn operations that can be sequentially
     performed when subsampling by a factor of 2.

     Eero Simoncelli, 6/96.
'''

import numpy as np
from scipy import interpolate
import warnings
from scipy import signal
import os


def maxPyrHt(imsz, filtsz):
    imsz = imsz.T
    filtsz = filtsz.T

    if (imsz == 1).any():  # 1D image
        imsz = np.prod(imsz)
        filtsz = np.prod(filtsz)
    elif (filtsz == 1).any():  # 2D image, 1D filter
        filtsz = [filtsz[0], filtsz[0]]

    if (imsz < filtsz).any():
        height = 0
    else:
        height = 1 + maxPyrHt(np.floor(imsz / 2), filtsz)

    return height


''' RES = pointOp(IM, LUT, ORIGIN, INCREMENT, WARNINGS)

Apply a point operation, specified by lookup table LUT, to image IM.
LUT must be a row or column vector, and is assumed to contain
(equi-spaced) samples of the function.  ORIGIN specifies the
abscissa associated with the first sample, and INCREMENT specifies the
spacing between samples.  Between-sample values are estimated via
linear interpolation.  If WARNINGS is non-zero, the function prints
a warning whenever the lookup table is extrapolated.

This function is much faster than MatLab's interp1, and allows
extrapolation beyond the lookup table domain.  The drawbacks are
that the lookup table must be equi-spaced, and the interpolation is
linear.

Eero Simoncelli, 8/96.
'''


def pointOp(im, lut, origin, increment):
    # NOTE: THIS CODE IS NOT ACTUALLY USED! (MEX FILE IS CALLED INSTEAD)

    X = origin + increment * np.arange(0, lut.shape[0])
    Y = lut

    res = np.reshape(interpolate.interp1d(X, Y, kind='linear', bounds_error=False, fill_value="extrapolate")(im),
                     im.shape)
    return res


''' RES = pyrBand(PYR, INDICES, BAND_NUM)

    Access a subband from a pyramid (gaussian, laplacian, QMF/wavelet,
    or steerable).  Subbands are numbered consecutively, from finest
    (highest spatial frequency) to coarsest (lowest spatial frequency).

    Eero Simoncelli, 6/96.
'''


def pyrBand(pyr, pind, band):
    res = np.reshape(pyr[(pyrBandIndices(pind, band))], [int(pind[int(band), 0]), int(pind[int(band), 1])], order="F")
    return res


''' RES = pyrBandIndices(INDICES, BAND_NUM)

    Return indices for accessing a subband from a pyramid
    (gaussian, laplacian, QMF/wavelet, steerable).

    Eero Simoncelli, 6/96.
'''


def pyrBandIndices(pind, band):
    if ((band > pind.shape[0] - 1) or (band < 0)):
        warnings.warn(f'BAND_NUM must be between 1 and number of pyramid bands ({pind.shape[0]}).')

    if (pind.shape[1] != 2):
        warnings.warn('INDICES must be an Nx2 matrix indicating the size of the pyramid subbands')

    ind = 0
    for l in np.arange(0, band):
        ind = ind + np.prod(pind[int(l), :])

    indices = np.arange(ind, ind + np.prod(pind[int(band), :]))

    return indices.astype(int)


'''The MIT License (MIT)

Copyright (c) 2016 LabForComputationalVision

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.'''


def Filters(filtername):
    if filtername == 'sp3Filters':
        harmonics = np.array([1, 3])
        mtx = (
            np.array([[0.5000, 0.3536, 0, -0.3536],
                      [-0.0000, 0.3536, 0.5000, 0.3536],
                      [0.5000, -0.3536, 0, 0.3536],
                      [-0.0000, 0.3536, -0.5000, 0.3536]]))
        hi0filt = (
            np.array([[-4.0483998600E-4, -6.2596000498E-4, -3.7829999201E-5,
                       8.8387000142E-4, 1.5450799838E-3, 1.9235999789E-3,
                       2.0687500946E-3, 2.0898699295E-3, 2.0687500946E-3,
                       1.9235999789E-3, 1.5450799838E-3, 8.8387000142E-4,
                       -3.7829999201E-5, -6.2596000498E-4, -4.0483998600E-4],
                      [-6.2596000498E-4, -3.2734998967E-4, 7.7435001731E-4,
                       1.5874400269E-3, 2.1750701126E-3, 2.5626500137E-3,
                       2.2892199922E-3, 1.9755100366E-3, 2.2892199922E-3,
                       2.5626500137E-3, 2.1750701126E-3, 1.5874400269E-3,
                       7.7435001731E-4, -3.2734998967E-4, -6.2596000498E-4],
                      [-3.7829999201E-5, 7.7435001731E-4, 1.1793200392E-3,
                       1.4050999889E-3, 2.2253401112E-3, 2.1145299543E-3,
                       3.3578000148E-4, -8.3368999185E-4, 3.3578000148E-4,
                       2.1145299543E-3, 2.2253401112E-3, 1.4050999889E-3,
                       1.1793200392E-3, 7.7435001731E-4, -3.7829999201E-5],
                      [8.8387000142E-4, 1.5874400269E-3, 1.4050999889E-3,
                       1.2960999738E-3, -4.9274001503E-4, -3.1295299996E-3,
                       -4.5751798898E-3, -5.1014497876E-3, -4.5751798898E-3,
                       -3.1295299996E-3, -4.9274001503E-4, 1.2960999738E-3,
                       1.4050999889E-3, 1.5874400269E-3, 8.8387000142E-4],
                      [1.5450799838E-3, 2.1750701126E-3, 2.2253401112E-3,
                       -4.9274001503E-4, -6.3222697936E-3, -2.7556000277E-3,
                       5.3632198833E-3, 7.3032598011E-3, 5.3632198833E-3,
                       -2.7556000277E-3, -6.3222697936E-3, -4.9274001503E-4,
                       2.2253401112E-3, 2.1750701126E-3, 1.5450799838E-3],
                      [1.9235999789E-3, 2.5626500137E-3, 2.1145299543E-3,
                       -3.1295299996E-3, -2.7556000277E-3, 1.3962360099E-2,
                       7.8046298586E-3, -9.3812197447E-3, 7.8046298586E-3,
                       1.3962360099E-2, -2.7556000277E-3, -3.1295299996E-3,
                       2.1145299543E-3, 2.5626500137E-3, 1.9235999789E-3],
                      [2.0687500946E-3, 2.2892199922E-3, 3.3578000148E-4,
                       -4.5751798898E-3, 5.3632198833E-3, 7.8046298586E-3,
                       -7.9501636326E-2, -0.1554141641, -7.9501636326E-2,
                       7.8046298586E-3, 5.3632198833E-3, -4.5751798898E-3,
                       3.3578000148E-4, 2.2892199922E-3, 2.0687500946E-3],
                      [2.0898699295E-3, 1.9755100366E-3, -8.3368999185E-4,
                       -5.1014497876E-3, 7.3032598011E-3, -9.3812197447E-3,
                       -0.1554141641, 0.7303866148, -0.1554141641,
                       -9.3812197447E-3, 7.3032598011E-3, -5.1014497876E-3,
                       -8.3368999185E-4, 1.9755100366E-3, 2.0898699295E-3],
                      [2.0687500946E-3, 2.2892199922E-3, 3.3578000148E-4,
                       -4.5751798898E-3, 5.3632198833E-3, 7.8046298586E-3,
                       -7.9501636326E-2, -0.1554141641, -7.9501636326E-2,
                       7.8046298586E-3, 5.3632198833E-3, -4.5751798898E-3,
                       3.3578000148E-4, 2.2892199922E-3, 2.0687500946E-3],
                      [1.9235999789E-3, 2.5626500137E-3, 2.1145299543E-3,
                       -3.1295299996E-3, -2.7556000277E-3, 1.3962360099E-2,
                       7.8046298586E-3, -9.3812197447E-3, 7.8046298586E-3,
                       1.3962360099E-2, -2.7556000277E-3, -3.1295299996E-3,
                       2.1145299543E-3, 2.5626500137E-3, 1.9235999789E-3],
                      [1.5450799838E-3, 2.1750701126E-3, 2.2253401112E-3,
                       -4.9274001503E-4, -6.3222697936E-3, -2.7556000277E-3,
                       5.3632198833E-3, 7.3032598011E-3, 5.3632198833E-3,
                       -2.7556000277E-3, -6.3222697936E-3, -4.9274001503E-4,
                       2.2253401112E-3, 2.1750701126E-3, 1.5450799838E-3],
                      [8.8387000142E-4, 1.5874400269E-3, 1.4050999889E-3,
                       1.2960999738E-3, -4.9274001503E-4, -3.1295299996E-3,
                       -4.5751798898E-3, -5.1014497876E-3, -4.5751798898E-3,
                       -3.1295299996E-3, -4.9274001503E-4, 1.2960999738E-3,
                       1.4050999889E-3, 1.5874400269E-3, 8.8387000142E-4],
                      [-3.7829999201E-5, 7.7435001731E-4, 1.1793200392E-3,
                       1.4050999889E-3, 2.2253401112E-3, 2.1145299543E-3,
                       3.3578000148E-4, -8.3368999185E-4, 3.3578000148E-4,
                       2.1145299543E-3, 2.2253401112E-3, 1.4050999889E-3,
                       1.1793200392E-3, 7.7435001731E-4, -3.7829999201E-5],
                      [-6.2596000498E-4, -3.2734998967E-4, 7.7435001731E-4,
                       1.5874400269E-3, 2.1750701126E-3, 2.5626500137E-3,
                       2.2892199922E-3, 1.9755100366E-3, 2.2892199922E-3,
                       2.5626500137E-3, 2.1750701126E-3, 1.5874400269E-3,
                       7.7435001731E-4, -3.2734998967E-4, -6.2596000498E-4],
                      [-4.0483998600E-4, -6.2596000498E-4, -3.7829999201E-5,
                       8.8387000142E-4, 1.5450799838E-3, 1.9235999789E-3,
                       2.0687500946E-3, 2.0898699295E-3, 2.0687500946E-3,
                       1.9235999789E-3, 1.5450799838E-3, 8.8387000142E-4,
                       -3.7829999201E-5, -6.2596000498E-4, -4.0483998600E-4]]))
        lo0filt = (
            np.array([[-8.7009997515E-5, -1.3542800443E-3, -1.6012600390E-3,
                       -5.0337001448E-4, 2.5240099058E-3, -5.0337001448E-4,
                       -1.6012600390E-3, -1.3542800443E-3, -8.7009997515E-5],
                      [-1.3542800443E-3, 2.9215801042E-3, 7.5227199122E-3,
                       8.2244202495E-3, 1.1076199589E-3, 8.2244202495E-3,
                       7.5227199122E-3, 2.9215801042E-3, -1.3542800443E-3],
                      [-1.6012600390E-3, 7.5227199122E-3, -7.0612900890E-3,
                       -3.7694871426E-2, -3.2971370965E-2, -3.7694871426E-2,
                       -7.0612900890E-3, 7.5227199122E-3, -1.6012600390E-3],
                      [-5.0337001448E-4, 8.2244202495E-3, -3.7694871426E-2,
                       4.3813198805E-2, 0.1811603010, 4.3813198805E-2,
                       -3.7694871426E-2, 8.2244202495E-3, -5.0337001448E-4],
                      [2.5240099058E-3, 1.1076199589E-3, -3.2971370965E-2,
                       0.1811603010, 0.4376249909, 0.1811603010,
                       -3.2971370965E-2, 1.1076199589E-3, 2.5240099058E-3],
                      [-5.0337001448E-4, 8.2244202495E-3, -3.7694871426E-2,
                       4.3813198805E-2, 0.1811603010, 4.3813198805E-2,
                       -3.7694871426E-2, 8.2244202495E-3, -5.0337001448E-4],
                      [-1.6012600390E-3, 7.5227199122E-3, -7.0612900890E-3,
                       -3.7694871426E-2, -3.2971370965E-2, -3.7694871426E-2,
                       -7.0612900890E-3, 7.5227199122E-3, -1.6012600390E-3],
                      [-1.3542800443E-3, 2.9215801042E-3, 7.5227199122E-3,
                       8.2244202495E-3, 1.1076199589E-3, 8.2244202495E-3,
                       7.5227199122E-3, 2.9215801042E-3, -1.3542800443E-3],
                      [-8.7009997515E-5, -1.3542800443E-3, -1.6012600390E-3,
                       -5.0337001448E-4, 2.5240099058E-3, -5.0337001448E-4,
                       -1.6012600390E-3, -1.3542800443E-3, -8.7009997515E-5]]))
        lofilt = (
            np.array([[-4.3500000174E-5, 1.2078000145E-4, -6.7714002216E-4,
                       -1.2434000382E-4, -8.0063997302E-4, -1.5970399836E-3,
                       -2.5168000138E-4, -4.2019999819E-4, 1.2619999470E-3,
                       -4.2019999819E-4, -2.5168000138E-4, -1.5970399836E-3,
                       -8.0063997302E-4, -1.2434000382E-4, -6.7714002216E-4,
                       1.2078000145E-4, -4.3500000174E-5],
                      [1.2078000145E-4, 4.4606000301E-4, -5.8146001538E-4,
                       5.6215998484E-4, -1.3688000035E-4, 2.3255399428E-3,
                       2.8898599558E-3, 4.2872801423E-3, 5.5893999524E-3,
                       4.2872801423E-3, 2.8898599558E-3, 2.3255399428E-3,
                       -1.3688000035E-4, 5.6215998484E-4, -5.8146001538E-4,
                       4.4606000301E-4, 1.2078000145E-4],
                      [-6.7714002216E-4, -5.8146001538E-4, 1.4607800404E-3,
                       2.1605400834E-3, 3.7613599561E-3, 3.0809799209E-3,
                       4.1121998802E-3, 2.2212199401E-3, 5.5381999118E-4,
                       2.2212199401E-3, 4.1121998802E-3, 3.0809799209E-3,
                       3.7613599561E-3, 2.1605400834E-3, 1.4607800404E-3,
                       -5.8146001538E-4, -6.7714002216E-4],
                      [-1.2434000382E-4, 5.6215998484E-4, 2.1605400834E-3,
                       3.1757799443E-3, 3.1846798956E-3, -1.7774800071E-3,
                       -7.4316998944E-3, -9.0569201857E-3, -9.6372198313E-3,
                       -9.0569201857E-3, -7.4316998944E-3, -1.7774800071E-3,
                       3.1846798956E-3, 3.1757799443E-3, 2.1605400834E-3,
                       5.6215998484E-4, -1.2434000382E-4],
                      [-8.0063997302E-4, -1.3688000035E-4, 3.7613599561E-3,
                       3.1846798956E-3, -3.5306399222E-3, -1.2604200281E-2,
                       -1.8847439438E-2, -1.7508180812E-2, -1.6485679895E-2,
                       -1.7508180812E-2, -1.8847439438E-2, -1.2604200281E-2,
                       -3.5306399222E-3, 3.1846798956E-3, 3.7613599561E-3,
                       -1.3688000035E-4, -8.0063997302E-4],
                      [-1.5970399836E-3, 2.3255399428E-3, 3.0809799209E-3,
                       -1.7774800071E-3, -1.2604200281E-2, -2.0229380578E-2,
                       -1.1091699824E-2, 3.9556599222E-3, 1.4385120012E-2,
                       3.9556599222E-3, -1.1091699824E-2, -2.0229380578E-2,
                       -1.2604200281E-2, -1.7774800071E-3, 3.0809799209E-3,
                       2.3255399428E-3, -1.5970399836E-3],
                      [-2.5168000138E-4, 2.8898599558E-3, 4.1121998802E-3,
                       -7.4316998944E-3, -1.8847439438E-2, -1.1091699824E-2,
                       2.1906599402E-2, 6.8065837026E-2, 9.0580143034E-2,
                       6.8065837026E-2, 2.1906599402E-2, -1.1091699824E-2,
                       -1.8847439438E-2, -7.4316998944E-3, 4.1121998802E-3,
                       2.8898599558E-3, -2.5168000138E-4],
                      [-4.2019999819E-4, 4.2872801423E-3, 2.2212199401E-3,
                       -9.0569201857E-3, -1.7508180812E-2, 3.9556599222E-3,
                       6.8065837026E-2, 0.1445499808, 0.1773651242,
                       0.1445499808, 6.8065837026E-2, 3.9556599222E-3,
                       -1.7508180812E-2, -9.0569201857E-3, 2.2212199401E-3,
                       4.2872801423E-3, -4.2019999819E-4],
                      [1.2619999470E-3, 5.5893999524E-3, 5.5381999118E-4,
                       -9.6372198313E-3, -1.6485679895E-2, 1.4385120012E-2,
                       9.0580143034E-2, 0.1773651242, 0.2120374441,
                       0.1773651242, 9.0580143034E-2, 1.4385120012E-2,
                       -1.6485679895E-2, -9.6372198313E-3, 5.5381999118E-4,
                       5.5893999524E-3, 1.2619999470E-3],
                      [-4.2019999819E-4, 4.2872801423E-3, 2.2212199401E-3,
                       -9.0569201857E-3, -1.7508180812E-2, 3.9556599222E-3,
                       6.8065837026E-2, 0.1445499808, 0.1773651242,
                       0.1445499808, 6.8065837026E-2, 3.9556599222E-3,
                       -1.7508180812E-2, -9.0569201857E-3, 2.2212199401E-3,
                       4.2872801423E-3, -4.2019999819E-4],
                      [-2.5168000138E-4, 2.8898599558E-3, 4.1121998802E-3,
                       -7.4316998944E-3, -1.8847439438E-2, -1.1091699824E-2,
                       2.1906599402E-2, 6.8065837026E-2, 9.0580143034E-2,
                       6.8065837026E-2, 2.1906599402E-2, -1.1091699824E-2,
                       -1.8847439438E-2, -7.4316998944E-3, 4.1121998802E-3,
                       2.8898599558E-3, -2.5168000138E-4],
                      [-1.5970399836E-3, 2.3255399428E-3, 3.0809799209E-3,
                       -1.7774800071E-3, -1.2604200281E-2, -2.0229380578E-2,
                       -1.1091699824E-2, 3.9556599222E-3, 1.4385120012E-2,
                       3.9556599222E-3, -1.1091699824E-2, -2.0229380578E-2,
                       -1.2604200281E-2, -1.7774800071E-3, 3.0809799209E-3,
                       2.3255399428E-3, -1.5970399836E-3],
                      [-8.0063997302E-4, -1.3688000035E-4, 3.7613599561E-3,
                       3.1846798956E-3, -3.5306399222E-3, -1.2604200281E-2,
                       -1.8847439438E-2, -1.7508180812E-2, -1.6485679895E-2,
                       -1.7508180812E-2, -1.8847439438E-2, -1.2604200281E-2,
                       -3.5306399222E-3, 3.1846798956E-3, 3.7613599561E-3,
                       -1.3688000035E-4, -8.0063997302E-4],
                      [-1.2434000382E-4, 5.6215998484E-4, 2.1605400834E-3,
                       3.1757799443E-3, 3.1846798956E-3, -1.7774800071E-3,
                       -7.4316998944E-3, -9.0569201857E-3, -9.6372198313E-3,
                       -9.0569201857E-3, -7.4316998944E-3, -1.7774800071E-3,
                       3.1846798956E-3, 3.1757799443E-3, 2.1605400834E-3,
                       5.6215998484E-4, -1.2434000382E-4],
                      [-6.7714002216E-4, -5.8146001538E-4, 1.4607800404E-3,
                       2.1605400834E-3, 3.7613599561E-3, 3.0809799209E-3,
                       4.1121998802E-3, 2.2212199401E-3, 5.5381999118E-4,
                       2.2212199401E-3, 4.1121998802E-3, 3.0809799209E-3,
                       3.7613599561E-3, 2.1605400834E-3, 1.4607800404E-3,
                       -5.8146001538E-4, -6.7714002216E-4],
                      [1.2078000145E-4, 4.4606000301E-4, -5.8146001538E-4,
                       5.6215998484E-4, -1.3688000035E-4, 2.3255399428E-3,
                       2.8898599558E-3, 4.2872801423E-3, 5.5893999524E-3,
                       4.2872801423E-3, 2.8898599558E-3, 2.3255399428E-3,
                       -1.3688000035E-4, 5.6215998484E-4, -5.8146001538E-4,
                       4.4606000301E-4, 1.2078000145E-4],
                      [-4.3500000174E-5, 1.2078000145E-4, -6.7714002216E-4,
                       -1.2434000382E-4, -8.0063997302E-4, -1.5970399836E-3,
                       -2.5168000138E-4, -4.2019999819E-4, 1.2619999470E-3,
                       -4.2019999819E-4, -2.5168000138E-4, -1.5970399836E-3,
                       -8.0063997302E-4, -1.2434000382E-4, -6.7714002216E-4,
                       1.2078000145E-4, -4.3500000174E-5]]))
        bfilts = (
            np.array([[-8.1125000725E-4, 4.4451598078E-3, 1.2316980399E-2,
                       1.3955879956E-2, 1.4179450460E-2, 1.3955879956E-2,
                       1.2316980399E-2, 4.4451598078E-3, -8.1125000725E-4,
                       3.9103501476E-3, 4.4565401040E-3, -5.8724298142E-3,
                       -2.8760801069E-3, 8.5267601535E-3, -2.8760801069E-3,
                       -5.8724298142E-3, 4.4565401040E-3, 3.9103501476E-3,
                       1.3462699717E-3, -3.7740699481E-3, 8.2581602037E-3,
                       3.9442278445E-2, 5.3605638444E-2, 3.9442278445E-2,
                       8.2581602037E-3, -3.7740699481E-3, 1.3462699717E-3,
                       7.4700999539E-4, -3.6522001028E-4, -2.2522680461E-2,
                       -0.1105690673, -0.1768419296, -0.1105690673,
                       -2.2522680461E-2, -3.6522001028E-4, 7.4700999539E-4,
                       0.0000000000, 0.0000000000, 0.0000000000,
                       0.0000000000, 0.0000000000, 0.0000000000,
                       0.0000000000, 0.0000000000, 0.0000000000,
                       -7.4700999539E-4, 3.6522001028E-4, 2.2522680461E-2,
                       0.1105690673, 0.1768419296, 0.1105690673,
                       2.2522680461E-2, 3.6522001028E-4, -7.4700999539E-4,
                       -1.3462699717E-3, 3.7740699481E-3, -8.2581602037E-3,
                       -3.9442278445E-2, -5.3605638444E-2, -3.9442278445E-2,
                       -8.2581602037E-3, 3.7740699481E-3, -1.3462699717E-3,
                       -3.9103501476E-3, -4.4565401040E-3, 5.8724298142E-3,
                       2.8760801069E-3, -8.5267601535E-3, 2.8760801069E-3,
                       5.8724298142E-3, -4.4565401040E-3, -3.9103501476E-3,
                       8.1125000725E-4, -4.4451598078E-3, -1.2316980399E-2,
                       -1.3955879956E-2, -1.4179450460E-2, -1.3955879956E-2,
                       -1.2316980399E-2, -4.4451598078E-3, 8.1125000725E-4],
                      [0.0000000000, -8.2846998703E-4, -5.7109999034E-5,
                       4.0110000555E-5, 4.6670897864E-3, 8.0871898681E-3,
                       1.4807609841E-2, 8.6204400286E-3, -3.1221499667E-3,
                       8.2846998703E-4, 0.0000000000, -9.7479997203E-4,
                       -6.9718998857E-3, -2.0865600090E-3, 2.3298799060E-3,
                       -4.4814897701E-3, 1.4917500317E-2, 8.6204400286E-3,
                       5.7109999034E-5, 9.7479997203E-4, 0.0000000000,
                       -1.2145539746E-2, -2.4427289143E-2, 5.0797060132E-2,
                       3.2785870135E-2, -4.4814897701E-3, 1.4807609841E-2,
                       -4.0110000555E-5, 6.9718998857E-3, 1.2145539746E-2,
                       0.0000000000, -0.1510555595, -8.2495503128E-2,
                       5.0797060132E-2, 2.3298799060E-3, 8.0871898681E-3,
                       -4.6670897864E-3, 2.0865600090E-3, 2.4427289143E-2,
                       0.1510555595, 0.0000000000, -0.1510555595,
                       -2.4427289143E-2, -2.0865600090E-3, 4.6670897864E-3,
                       -8.0871898681E-3, -2.3298799060E-3, -5.0797060132E-2,
                       8.2495503128E-2, 0.1510555595, 0.0000000000,
                       -1.2145539746E-2, -6.9718998857E-3, 4.0110000555E-5,
                       -1.4807609841E-2, 4.4814897701E-3, -3.2785870135E-2,
                       -5.0797060132E-2, 2.4427289143E-2, 1.2145539746E-2,
                       0.0000000000, -9.7479997203E-4, -5.7109999034E-5,
                       -8.6204400286E-3, -1.4917500317E-2, 4.4814897701E-3,
                       -2.3298799060E-3, 2.0865600090E-3, 6.9718998857E-3,
                       9.7479997203E-4, 0.0000000000, -8.2846998703E-4,
                       3.1221499667E-3, -8.6204400286E-3, -1.4807609841E-2,
                       -8.0871898681E-3, -4.6670897864E-3, -4.0110000555E-5,
                       5.7109999034E-5, 8.2846998703E-4, 0.0000000000],
                      [8.1125000725E-4, -3.9103501476E-3, -1.3462699717E-3,
                       -7.4700999539E-4, 0.0000000000, 7.4700999539E-4,
                       1.3462699717E-3, 3.9103501476E-3, -8.1125000725E-4,
                       -4.4451598078E-3, -4.4565401040E-3, 3.7740699481E-3,
                       3.6522001028E-4, 0.0000000000, -3.6522001028E-4,
                       -3.7740699481E-3, 4.4565401040E-3, 4.4451598078E-3,
                       -1.2316980399E-2, 5.8724298142E-3, -8.2581602037E-3,
                       2.2522680461E-2, 0.0000000000, -2.2522680461E-2,
                       8.2581602037E-3, -5.8724298142E-3, 1.2316980399E-2,
                       -1.3955879956E-2, 2.8760801069E-3, -3.9442278445E-2,
                       0.1105690673, 0.0000000000, -0.1105690673,
                       3.9442278445E-2, -2.8760801069E-3, 1.3955879956E-2,
                       -1.4179450460E-2, -8.5267601535E-3, -5.3605638444E-2,
                       0.1768419296, 0.0000000000, -0.1768419296,
                       5.3605638444E-2, 8.5267601535E-3, 1.4179450460E-2,
                       -1.3955879956E-2, 2.8760801069E-3, -3.9442278445E-2,
                       0.1105690673, 0.0000000000, -0.1105690673,
                       3.9442278445E-2, -2.8760801069E-3, 1.3955879956E-2,
                       -1.2316980399E-2, 5.8724298142E-3, -8.2581602037E-3,
                       2.2522680461E-2, 0.0000000000, -2.2522680461E-2,
                       8.2581602037E-3, -5.8724298142E-3, 1.2316980399E-2,
                       -4.4451598078E-3, -4.4565401040E-3, 3.7740699481E-3,
                       3.6522001028E-4, 0.0000000000, -3.6522001028E-4,
                       -3.7740699481E-3, 4.4565401040E-3, 4.4451598078E-3,
                       8.1125000725E-4, -3.9103501476E-3, -1.3462699717E-3,
                       -7.4700999539E-4, 0.0000000000, 7.4700999539E-4,
                       1.3462699717E-3, 3.9103501476E-3, -8.1125000725E-4],
                      [3.1221499667E-3, -8.6204400286E-3, -1.4807609841E-2,
                       -8.0871898681E-3, -4.6670897864E-3, -4.0110000555E-5,
                       5.7109999034E-5, 8.2846998703E-4, 0.0000000000,
                       -8.6204400286E-3, -1.4917500317E-2, 4.4814897701E-3,
                       -2.3298799060E-3, 2.0865600090E-3, 6.9718998857E-3,
                       9.7479997203E-4, -0.0000000000, -8.2846998703E-4,
                       -1.4807609841E-2, 4.4814897701E-3, -3.2785870135E-2,
                       -5.0797060132E-2, 2.4427289143E-2, 1.2145539746E-2,
                       0.0000000000, -9.7479997203E-4, -5.7109999034E-5,
                       -8.0871898681E-3, -2.3298799060E-3, -5.0797060132E-2,
                       8.2495503128E-2, 0.1510555595, -0.0000000000,
                       -1.2145539746E-2, -6.9718998857E-3, 4.0110000555E-5,
                       -4.6670897864E-3, 2.0865600090E-3, 2.4427289143E-2,
                       0.1510555595, 0.0000000000, -0.1510555595,
                       -2.4427289143E-2, -2.0865600090E-3, 4.6670897864E-3,
                       -4.0110000555E-5, 6.9718998857E-3, 1.2145539746E-2,
                       0.0000000000, -0.1510555595, -8.2495503128E-2,
                       5.0797060132E-2, 2.3298799060E-3, 8.0871898681E-3,
                       5.7109999034E-5, 9.7479997203E-4, -0.0000000000,
                       -1.2145539746E-2, -2.4427289143E-2, 5.0797060132E-2,
                       3.2785870135E-2, -4.4814897701E-3, 1.4807609841E-2,
                       8.2846998703E-4, -0.0000000000, -9.7479997203E-4,
                       -6.9718998857E-3, -2.0865600090E-3, 2.3298799060E-3,
                       -4.4814897701E-3, 1.4917500317E-2, 8.6204400286E-3,
                       0.0000000000, -8.2846998703E-4, -5.7109999034E-5,
                       4.0110000555E-5, 4.6670897864E-3, 8.0871898681E-3,
                       1.4807609841E-2, 8.6204400286E-3, -3.1221499667E-3]]).T)


    elif filtername == 'sp0Filters':
        harmonics = np.array([0])
        lo0filt = (
            np.array([[-4.514000e-04, -1.137100e-04, -3.725800e-04, -3.743860e-03,
                       -3.725800e-04, -1.137100e-04, -4.514000e-04],
                      [-1.137100e-04, -6.119520e-03, -1.344160e-02, -7.563200e-03,
                       -1.344160e-02, -6.119520e-03, -1.137100e-04],
                      [-3.725800e-04, -1.344160e-02, 6.441488e-02, 1.524935e-01,
                       6.441488e-02, -1.344160e-02, -3.725800e-04],
                      [-3.743860e-03, -7.563200e-03, 1.524935e-01, 3.153017e-01,
                       1.524935e-01, -7.563200e-03, -3.743860e-03],
                      [-3.725800e-04, -1.344160e-02, 6.441488e-02, 1.524935e-01,
                       6.441488e-02, -1.344160e-02, -3.725800e-04],
                      [-1.137100e-04, -6.119520e-03, -1.344160e-02, -7.563200e-03,
                       -1.344160e-02, -6.119520e-03, -1.137100e-04],
                      [-4.514000e-04, -1.137100e-04, -3.725800e-04, -3.743860e-03,
                       -3.725800e-04, -1.137100e-04, -4.514000e-04]]))
        lofilt = (
            np.array([[-2.257000e-04, -8.064400e-04, -5.686000e-05, 8.741400e-04,
                       -1.862800e-04, -1.031640e-03, -1.871920e-03, -1.031640e-03,
                       -1.862800e-04, 8.741400e-04, -5.686000e-05, -8.064400e-04,
                       -2.257000e-04],
                      [-8.064400e-04, 1.417620e-03, -1.903800e-04, -2.449060e-03,
                       -4.596420e-03, -7.006740e-03, -6.948900e-03, -7.006740e-03,
                       -4.596420e-03, -2.449060e-03, -1.903800e-04, 1.417620e-03,
                       -8.064400e-04],
                      [-5.686000e-05, -1.903800e-04, -3.059760e-03, -6.401000e-03,
                       -6.720800e-03, -5.236180e-03, -3.781600e-03, -5.236180e-03,
                       -6.720800e-03, -6.401000e-03, -3.059760e-03, -1.903800e-04,
                       -5.686000e-05],
                      [8.741400e-04, -2.449060e-03, -6.401000e-03, -5.260020e-03,
                       3.938620e-03, 1.722078e-02, 2.449600e-02, 1.722078e-02,
                       3.938620e-03, -5.260020e-03, -6.401000e-03, -2.449060e-03,
                       8.741400e-04],
                      [-1.862800e-04, -4.596420e-03, -6.720800e-03, 3.938620e-03,
                       3.220744e-02, 6.306262e-02, 7.624674e-02, 6.306262e-02,
                       3.220744e-02, 3.938620e-03, -6.720800e-03, -4.596420e-03,
                       -1.862800e-04],
                      [-1.031640e-03, -7.006740e-03, -5.236180e-03, 1.722078e-02,
                       6.306262e-02, 1.116388e-01, 1.348999e-01, 1.116388e-01,
                       6.306262e-02, 1.722078e-02, -5.236180e-03, -7.006740e-03,
                       -1.031640e-03],
                      [-1.871920e-03, -6.948900e-03, -3.781600e-03, 2.449600e-02,
                       7.624674e-02, 1.348999e-01, 1.576508e-01, 1.348999e-01,
                       7.624674e-02, 2.449600e-02, -3.781600e-03, -6.948900e-03,
                       -1.871920e-03],
                      [-1.031640e-03, -7.006740e-03, -5.236180e-03, 1.722078e-02,
                       6.306262e-02, 1.116388e-01, 1.348999e-01, 1.116388e-01,
                       6.306262e-02, 1.722078e-02, -5.236180e-03, -7.006740e-03,
                       -1.031640e-03],
                      [-1.862800e-04, -4.596420e-03, -6.720800e-03, 3.938620e-03,
                       3.220744e-02, 6.306262e-02, 7.624674e-02, 6.306262e-02,
                       3.220744e-02, 3.938620e-03, -6.720800e-03, -4.596420e-03,
                       -1.862800e-04],
                      [8.741400e-04, -2.449060e-03, -6.401000e-03, -5.260020e-03,
                       3.938620e-03, 1.722078e-02, 2.449600e-02, 1.722078e-02,
                       3.938620e-03, -5.260020e-03, -6.401000e-03, -2.449060e-03,
                       8.741400e-04],
                      [-5.686000e-05, -1.903800e-04, -3.059760e-03, -6.401000e-03,
                       -6.720800e-03, -5.236180e-03, -3.781600e-03, -5.236180e-03,
                       -6.720800e-03, -6.401000e-03, -3.059760e-03, -1.903800e-04,
                       -5.686000e-05],
                      [-8.064400e-04, 1.417620e-03, -1.903800e-04, -2.449060e-03,
                       -4.596420e-03, -7.006740e-03, -6.948900e-03, -7.006740e-03,
                       -4.596420e-03, -2.449060e-03, -1.903800e-04, 1.417620e-03,
                       -8.064400e-04],
                      [-2.257000e-04, -8.064400e-04, -5.686000e-05, 8.741400e-04,
                       -1.862800e-04, -1.031640e-03, -1.871920e-03, -1.031640e-03,
                       -1.862800e-04, 8.741400e-04, -5.686000e-05, -8.064400e-04,
                       -2.257000e-04]]))
        mtx = np.array([1.000000])
        hi0filt = (
            np.array([[5.997200e-04, -6.068000e-05, -3.324900e-04, -3.325600e-04,
                       -2.406600e-04, -3.325600e-04, -3.324900e-04, -6.068000e-05,
                       5.997200e-04],
                      [-6.068000e-05, 1.263100e-04, 4.927100e-04, 1.459700e-04,
                       -3.732100e-04, 1.459700e-04, 4.927100e-04, 1.263100e-04,
                       -6.068000e-05],
                      [-3.324900e-04, 4.927100e-04, -1.616650e-03, -1.437358e-02,
                       -2.420138e-02, -1.437358e-02, -1.616650e-03, 4.927100e-04,
                       -3.324900e-04],
                      [-3.325600e-04, 1.459700e-04, -1.437358e-02, -6.300923e-02,
                       -9.623594e-02, -6.300923e-02, -1.437358e-02, 1.459700e-04,
                       -3.325600e-04],
                      [-2.406600e-04, -3.732100e-04, -2.420138e-02, -9.623594e-02,
                       8.554893e-01, -9.623594e-02, -2.420138e-02, -3.732100e-04,
                       -2.406600e-04],
                      [-3.325600e-04, 1.459700e-04, -1.437358e-02, -6.300923e-02,
                       -9.623594e-02, -6.300923e-02, -1.437358e-02, 1.459700e-04,
                       -3.325600e-04],
                      [-3.324900e-04, 4.927100e-04, -1.616650e-03, -1.437358e-02,
                       -2.420138e-02, -1.437358e-02, -1.616650e-03, 4.927100e-04,
                       -3.324900e-04],
                      [-6.068000e-05, 1.263100e-04, 4.927100e-04, 1.459700e-04,
                       -3.732100e-04, 1.459700e-04, 4.927100e-04, 1.263100e-04,
                       -6.068000e-05],
                      [5.997200e-04, -6.068000e-05, -3.324900e-04, -3.325600e-04,
                       -2.406600e-04, -3.325600e-04, -3.324900e-04, -6.068000e-05,
                       5.997200e-04]]))
        bfilts = (
            np.array([-9.066000e-05, -1.738640e-03, -4.942500e-03, -7.889390e-03,
                      -1.009473e-02, -7.889390e-03, -4.942500e-03, -1.738640e-03,
                      -9.066000e-05, -1.738640e-03, -4.625150e-03, -7.272540e-03,
                      -7.623410e-03, -9.091950e-03, -7.623410e-03, -7.272540e-03,
                      -4.625150e-03, -1.738640e-03, -4.942500e-03, -7.272540e-03,
                      -2.129540e-02, -2.435662e-02, -3.487008e-02, -2.435662e-02,
                      -2.129540e-02, -7.272540e-03, -4.942500e-03, -7.889390e-03,
                      -7.623410e-03, -2.435662e-02, -1.730466e-02, -3.158605e-02,
                      -1.730466e-02, -2.435662e-02, -7.623410e-03, -7.889390e-03,
                      -1.009473e-02, -9.091950e-03, -3.487008e-02, -3.158605e-02,
                      9.464195e-01, -3.158605e-02, -3.487008e-02, -9.091950e-03,
                      -1.009473e-02, -7.889390e-03, -7.623410e-03, -2.435662e-02,
                      -1.730466e-02, -3.158605e-02, -1.730466e-02, -2.435662e-02,
                      -7.623410e-03, -7.889390e-03, -4.942500e-03, -7.272540e-03,
                      -2.129540e-02, -2.435662e-02, -3.487008e-02, -2.435662e-02,
                      -2.129540e-02, -7.272540e-03, -4.942500e-03, -1.738640e-03,
                      -4.625150e-03, -7.272540e-03, -7.623410e-03, -9.091950e-03,
                      -7.623410e-03, -7.272540e-03, -4.625150e-03, -1.738640e-03,
                      -9.066000e-05, -1.738640e-03, -4.942500e-03, -7.889390e-03,
                      -1.009473e-02, -7.889390e-03, -4.942500e-03, -1.738640e-03,
                      -9.066000e-05]))
        bfilts = bfilts.reshape(len(bfilts), 1)
    return [lo0filt, hi0filt, lofilt, bfilts, mtx, harmonics]


''' [HEIGHT] = spyrHt(INDICES)

    Compute height of steerable pyramid with given index matrix.

    Eero Simoncelli, 6/96.
'''


def spyrHt(pind):
    nbands = spyrNumBands(pind)

    # Don't count lowpass, or highpass residual bands
    if (pind.shape[0] > 2):
        ht = (pind.shape[0] - 2) / nbands
    else:
        ht = 0
    return ht


''' [NBANDS] = spyrNumBands(INDICES)

    Compute number of orientation bands in a steerable pyramid with
    given index matrix.  If the pyramid contains only the highpass and
    lowpass bands (i.e., zero levels), returns 0.

    Eero Simoncelli, 2/97.
'''


def spyrNumBands(pind):
    if (pind.shape[0] == 2):
        nbands = 0
    else:
        # Count number of orientation bands:
        b = 2
        while ((b <= pind.shape[0]) and (pind[b, :] == pind[1, :]).all()):
            b = b + 1
        nbands = b - 2
    return nbands + 1


'''RES = corrDn(IM, FILT, EDGES, STEP, START, STOP)

Compute correlation of matrices IM with FILT, followed by
downsampling.  These arguments should be 1D or 2D matrices, and IM
must be larger (in both dimensions) than FILT.  The origin of filt
is assumed to be floor(size(filt)/2)+1.

EDGES is a string determining boundary handling:
   'circular' - Circular convolution
   'reflect1' - Reflect about the edge pixels
   'reflect2' - Reflect, doubling the edge pixels
   'repeat'   - Repeat the edge pixels
   'zero'     - Assume values of zero outside image boundary
   'extend'   - Reflect and invert (continuous values and derivs)
   'dont-compute' - Zero output when filter overhangs input boundaries

Downsampling factors are determined by STEP (optional, default=[1 1]),
which should be a 2-vector [y,x].

The window over which the convolution occurs is specfied by START
(optional, default=[1,1], and STOP (optional, default=size(IM)).

NOTE: this operation corresponds to multiplication of a signal
vector by a matrix whose rows contain copies of the FILT shifted by
multiples of STEP.  See upConv.m for the operation corresponding to
the transpose of this matrix.

Eero Simoncelli, 6/96, revised 2/97.
'''


def corrDn(im, filt, edges, step=[1, 1], start=[0, 0]):
    if ('edges' in dir()):
        if (edges != 'reflect1'):
            warnings.warn('Using REFLECT1 edge-handling (use MEX code for other options).')

    if ('stop' not in dir()):
        stop = im.shape

    # Reverse order of taps in filt, to do correlation instead of convolution
    filt = filt[::-1, :]
    filt = filt[:, ::-1]
    tmp = rconv2(im, filt)
    tmp = tmp[start[0]:stop[0], start[1]:stop[1]]
    res = tmp[::step[0], ::step[1]]
    return res


''' RES = RCONV2(MTX1, MTX2, CTR)

    Convolution of two matrices, with boundaries handled via reflection
    about the edge pixels.  Result will be of size of LARGER matrix.

    The origin of the smaller matrix is assumed to be its center.
    For even dimensions, the origin is determined by the CTR (optional)
    argument:
         CTR   origin
          0     DIM/2      (default)
          1     (DIM/2)+1

    Eero Simoncelli, 6/96.
'''


def rconv2(*args):
    ''' Convolution of two matrices, with boundaries handled via reflection
        about the edge pixels.  Result will be of size of LARGER matrix.

        The origin of the smaller matrix is assumed to be its center.
        For even dimensions, the origin is determined by the CTR (optional)
        argument:
             CTR   origin
              0     DIM/2      (default)
              1   (DIM/2)+1  '''

    if len(args) < 2:
        print
        "Error: two matrices required as input parameters"
        return

    if len(args) == 2:
        ctr = 0

    if (args[0].shape[0] >= args[1].shape[0] and
            args[0].shape[1] >= args[1].shape[1]):
        large = args[0]
        small = args[1]
    elif (args[0].shape[0] <= args[1].shape[0] and
          args[0].shape[1] <= args[1].shape[1]):
        large = args[1]
        small = args[0]
    else:
        print
        'one arg must be larger than the other in both dimensions!'
        return

    ly = large.shape[0]
    lx = large.shape[1]
    sy = small.shape[0]
    sx = small.shape[1]

    ## These values are one less than the index of the small mtx that falls on
    ## the border pixel of the large matrix when computing the first
    ## convolution response sample:
    sy2 = int(np.floor((sy + ctr - 1) / 2))
    sx2 = int(np.floor((sx + ctr - 1) / 2))

    # pad with reflected copies
    nw = large[sy - sy2 - 1:0:-1, sx - sx2 - 1:0:-1]
    n = large[sy - sy2 - 1:0:-1, :]
    ne = large[sy - sy2 - 1:0:-1, lx - 2:lx - sx2 - 2:-1]
    w = large[:, sx - sx2 - 1:0:-1]
    e = large[:, lx - 2:lx - sx2 - 2:-1]
    sw = large[ly - 2:ly - sy2 - 2:-1, sx - sx2 - 1:0:-1]
    s = large[ly - 2:ly - sy2 - 2:-1, :]
    se = large[ly - 2:ly - sy2 - 2:-1, lx - 2:lx - sx2 - 2:-1]

    n = np.column_stack((nw, n, ne))
    c = np.column_stack((w, large, e))
    s = np.column_stack((sw, s, se))

    clarge = np.concatenate((n, c), axis=0)
    clarge = np.concatenate((clarge, s), axis=0)

    c = signal.convolve2d(clarge, small, 'valid')
    return c


'''[PYR, INDICES, STEERMTX, HARMONICS] = buildSpyr(IM, HEIGHT, FILTFILE, EDGES)

Construct a steerable pyramid on matrix IM.  Convolutions are
done with spatial filters.

HEIGHT (optional) specifies the number of pyramid levels to build. Default
is maxPyrHt(size(IM),size(FILT)).
You can also specify 'auto' to use this value.

FILTFILE (optional) should be a string referring to an m-file that
returns the rfilters.  (examples: 'sp0Filters', 'sp1Filters',
'sp3Filters','sp5Filters'.  default = 'sp1Filters'). EDGES specifies
edge-handling, and defaults to 'reflect1' (see corrDn).

PYR is a vector containing the N pyramid subbands, ordered from fine
to coarse.  INDICES is an Nx2 matrix containing the sizes of
each subband.  This is compatible with the MatLab Wavelet toolbox.
See the function STEER for a description of STEERMTX and HARMONICS.

Eero Simoncelli, 6/96.
See http://www.cis.upenn.edu/~eero/steerpyr.html for more
information about the Steerable Pyramid image decomposition.
'''


def buildSpyr(im, ht, filtfile='sp1Filters', edges='reflect1'):
    if (isinstance(filtfile, str) and ('filtfile' in dir())):
        # [lo0filt,hi0filt,lofilt,bfilts,steermtx,harmonics] = eval(filtfile)
        [lo0filt, hi0filt, lofilt, bfilts, steermtx, harmonics] = Filters(filtfile)
    else:
        print(1, '\nUse buildSFpyr for pyramids with arbitrary numbers of orientation bands.\n')
        warnings.warn('FILTFILE argument must be the name of an M-file containing SPYR filters.')

    max_ht = maxPyrHt(np.array(im.shape), np.array(lofilt.shape[0]))
    if ('ht' not in dir() or (ht == 'auto')):
        ht = max_ht
    else:
        if (ht > max_ht):
            warnings.warn(f'Cannot build pyramid higher than {max_ht} levels.')

    hi0 = corrDn(im, hi0filt, edges)
    lo0 = corrDn(im, lo0filt, edges)
    hpind = np.array(hi0.shape)
    [pyr, pind] = buildSpyrLevs(lo0, ht, lofilt, bfilts, edges)
    hi0 = (hi0.T).flatten()
    pyr = np.concatenate([hi0, pyr], axis=0)
    pind = np.vstack((hpind, pind))
    return [pyr, pind, steermtx, harmonics]


'''[PYR, INDICES] = buildSpyrLevs(LOIM, HEIGHT, LOFILT, BFILTS, EDGES)

Recursive function for constructing levels of a steerable pyramid.  This
is called by buildSpyr, and is not usually called directly.

Eero Simoncelli, 6/96.
'''


def buildSpyrLevs(lo0, ht, lofilt, bfilts, edges):
    pyr = np.array([])
    pind = np.array([])
    i = 0
    while (1):
        if (ht <= 0):
            pyr = np.concatenate((pyr, lo0.T.flatten().T), axis=0)
            pind = np.vstack((pind, np.array(lo0.shape)))
            break
        else:

            # Assume square filters:
            bfiltsz = round(np.sqrt(bfilts.shape[0]))

            bands = np.zeros([np.prod(lo0.shape), bfilts.shape[1]])
            bind = np.zeros([bfilts.shape[1], 2])

            for b in np.arange(0, bfilts.shape[1]):
                filt = np.reshape(bfilts[:, b], [bfiltsz, bfiltsz], order="F")
                band = corrDn(lo0, filt, edges)
                bands[:, b] = (band.T).flatten()
                bind[b, :] = band.shape

            lo = corrDn(lo0, lofilt, edges, [2, 2], [0, 0])
            lo0 = lo
            ht = ht - 1
            pyr = np.concatenate((pyr, (bands.T).flatten()), axis=0)
            if i == 0:
                pind = bind
                i = i + 1
            else:
                pind = np.concatenate((pind, bind), axis=0)

    return [pyr, pind]


def upConv(im, filt, edges='reflect1', step=(1, 1), start=(0, 0), stop=None, res=None):
    # THIS CODE IS NOT ACTUALLY USED! (MEX FILE IS CALLED INSTEAD)

    if edges != 'reflect1':
        print('Using REFLECT1 edge-handling (use MEX code for other options).')

    if stop is None:
        stop = tuple(step[i] * (np.floor((start[i]) / step[i]) + im.shape[i]) for i in range(2))

    if np.ceil((stop[0] - start[0]) / step[0]) != im.shape[0]:
        raise ValueError('Bad Y result dimension')
    if np.ceil((stop[1] - start[1]) / step[1]) != im.shape[1]:
        raise ValueError('Bad X result dimension')

    if res is None:
        res = np.zeros([int(stop[0] - start[0]), int(stop[1] - start[1])])

    tmp = np.zeros_like(res)
    tmp[start[0]:int(stop[0]):step[0], start[1]:int(stop[1]):step[1]] = im

    result = rconv2(tmp, filt) + res
    return result


def reconSpyrLevs(pyr, pind, lofilt, bfilts, edges, levs, bands):
    # Deterimine whether MEX version of upConv is available

    nbands = bfilts.shape[1]
    lo_ind = nbands

    # Assume square filters:
    bfiltsz = int(np.sqrt(bfilts.shape[0]))
    res_sz = pind[0]
    if any(levs > 1):
        if pind.shape[0] > lo_ind + 1:

            nres = reconSpyrLevs(pyr[int(np.sum(np.prod(pind[:lo_ind], axis=1))):], pind[lo_ind:], lofilt,
                                 bfilts,
                                 edges, levs - 1, bands)
        else:
            nres = pyrBand(pyr, pind, lo_ind)  # lowpass subband

        res = upConv(nres, lofilt, edges, (2, 2), (0, 0), tuple(res_sz))
    else:
        res = np.zeros_like(res_sz)
    if any(levs == 1):
        ind = 0
        for b in range(nbands):
            if any(bands == b + 1):
                bfilt = bfilts[:, b].reshape(bfiltsz, bfiltsz, order="F")
                res += upConv(pyr[int(ind):int(ind + np.prod(res_sz))].reshape(np.array(res_sz).astype(int), order="F"),
                              bfilt, edges,
                              (1, 1), (0, 0), tuple(res_sz))
            ind += np.prod(res_sz)

    return res


def subMtx(vec, sz, offset=0):
    vec = vec.ravel()
    sz = np.array(sz).ravel()

    if sz.size != 2:
        raise ValueError('DIMENSIONS must be a 2-vector.')

    mtx = vec[offset:int(offset + np.prod(sz))].reshape(sz.astype(int), order="F")
    return mtx


'''RES = reconSpyr(PYR, INDICES, FILTFILE, EDGES, LEVS, BANDS)

 Reconstruct image from its steerable pyramid representation, as created
 by buildSpyr.

 PYR is a vector containing the N pyramid subbands, ordered from fine
 to coarse.  INDICES is an Nx2 matrix containing the sizes of
 each subband.  This is compatible with the MatLab Wavelet toolbox.

 FILTFILE (optional) should be a string referring to an m-file that returns
 the rfilters.  examples: sp0Filters, sp1Filters, sp3Filters 
 (default = 'sp1Filters'). 
 EDGES specifies edge-handling, and defaults to 'reflect1' (see
 corrDn).
 
 LEVS (optional) should be a list of levels to include, or the string
 'all' (default).  0 corresonds to the residual highpass subband.  
 1 corresponds to the finest oriented scale.  The lowpass band
 corresponds to number spyrHt(INDICES)+1.

 BANDS (optional) should be a list of bands to include, or the string
 'all' (default).  1 = vertical, rest proceeding anti-clockwise.

 Eero Simoncelli, 6/96.'''


def reconSpyr(pyr, pind, filtfile='sp1Filters', edges='reflect1', levs='all', bands='all'):
    # Deterimine whether a MEX version of upConv is available

    if isinstance(filtfile, str):
        lo0filt, hi0filt, lofilt, bfilts, steermtx, harmonics = Filters(filtfile)
        nbands = spyrNumBands(pind)
        if nbands > 0 and bfilts.shape[1] != nbands:
            raise ValueError('Number of pyramid bands is inconsistent with filter file')
    else:
        raise ValueError('filtfile argument must be the name of an M-file containing SPYR filters.')

    maxLev = 1 + spyrHt(pind)
    if levs == 'all':
        levs = np.arange(0, maxLev + 1)
    else:
        if any(levs > maxLev) or any(levs < 0):
            raise ValueError(f'Level numbers must be in the range [0, {maxLev}].')
        levs = np.array(levs)

    if bands == 'all':
        bands = np.arange(1, nbands + 1)
    else:
        if any(bands < 1) or any(bands > nbands):
            raise ValueError(f'Band numbers must be in the range [1,{nbands}].')
        bands = np.array(bands)

    if spyrHt(pind) == 0:
        if any(levs == 1):
            res1 = pyrBand(pyr, pind, 2)
        else:
            res1 = np.zeros(pind[1])
    else:
        res1 = reconSpyrLevs(pyr[int(np.prod(pind[0])):], pind[1:], lofilt, bfilts, edges, levs, bands)

    res = upConv(res1, lo0filt, edges)

    # residual highpass subband
    if any(levs == 0):
        res = upConv(subMtx(pyr, pind[0]), hi0filt, edges, (1, 1), (0, 0), res.shape, res)

    return res
